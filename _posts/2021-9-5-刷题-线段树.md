---
layout: post
title:  线段树
categories: Interview
---
# Youtube
讲解 https://www.youtube.com/watch?v=TbPuUkEWY2Y

# Size
Size of segement tree using array is 2n-1, because n+n/2+n/4+...1 = 2n-1

So we can make the root in index 1, so its left, and right childend will be `2*i` and `2*i+1`

# implementations:
## Dropbox allocate ID
```py
class Allocator:
    def __init__(self,size):
        self.capacity = size
        self.data = [False] * 2 * size
    
    def allocate(self):
        if self.data[1] == True:
            print("no avaiable slots")
            return
        idx = 1
        while idx < self.capacity:
            left, right = idx*2, idx*2+1
            if self.data[left] and self.data[right]:
                print("no avaiable slots")
                return
            if not self.data[left]:
                idx = left
            else:
                idx = right
        self.data[idx] = True
        print("allocating {}".format(idx-self.capacity))
        # updating segment tree
        while idx > 1:
            p = idx // 2
            left, right = p*2, p*2+1
            if  self.data[left] and self.data[right]:
                self.data[p] = True
                idx = p
            else:
                break


    def release(self, id):
        if id < 0 or id >= self.capacity:
            print("id out of range")
            return
        target = id + self.capacity
        if self.data[target] == False:
            print("{} is not occupied".format(id))
            return
        print("releasing {}".format(id))
        self.data[target] = False
        idx = target
        while idx > 1:
            p = idx // 2
            left, right = p*2, p*2+1
            if not self.data[left] and not self.data[right]:
                self.data[p] = False
                idx = p
            else:
                break
allocator = Allocator(10)
for i in range(11):
    allocator.allocate()
for i in range(11):
    allocator.release(i)
for i in range(3):
    allocator.release(i)
```

## LC 307
https://leetcode.com/problems/range-sum-query-mutable/

### using array
```py
class NumArray(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.size = len(nums)
        self.data = [0] * (2*self.size)
        for i in range(self.size,len(self.data)):
            self.data[i] = nums[i-self.size]
        for i in range(self.size-1,0,-1):
            l,r = 2*i,2*i+1
            self.data[i] = self.data[l] + self.data[r]


    def update(self, index, val):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        index += self.size
        diff = val - self.data[index]
        while index > 0:
            self.data[index] += diff
            index //= 2

    def sumRange(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: int
        """
        res = 0
        left += self.size
        right += self.size
        while left <= right :
            # if left % 2 == 1, then we discard all elements in [1:left], so we do left += 1
            if left % 2 == 1:
                res += self.data[left]
                left += 1
            # if right % 2 == 0: then all numbers in [right:], we discard all of them, we can do right -= 1
            if right % 2 == 0:
                res += self.data[right]
                right -= 1
            left //= 2
            right //= 2
        return res
```

### using tree
```py
class NumArray(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.size = len(nums)
        self.root = self.__buildTree(nums, 0, len(nums)-1)

    def __buildTree(self, nums, left, right):
        if left>right:
            return None
        if left == right:
            return Node(left,right,nums[left])
        root = Node(left,right)
        mid = (left+right)//2
        root.left = self.__buildTree(nums, left, mid)
        root.right = self.__buildTree(nums, mid+1, right)
        root.total = root.left.total + root.right.total
        return root
        

    def update(self, index, val):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        root = self.root
        path = set()
        while True:
            path.add(root)
            l,r = root.start, root.end
            if l == r == index:
                break
            mid = (l+r)//2
            if index <= mid:
                root = root.left
            else:
                root = root.right
        diff = val - root.total
        for r in path:
            r.total += diff

    def sumRange(self, left, right):
        def helper(root, left, right):
            # if not root or left > right:
            #     return 0
            s,e = root.start, root.end
            if s == left and e == right:
                return root.total
            mid = (s+e)//2
            # entire range is in right sub tree
            if mid+1 <= left:
                return helper(root.right, left, right)
            # entire range is in left sub tree
            if right <= mid:
                return helper(root.left, left, right)
            return helper(root.left, left, mid) + helper(root.right, mid+1, right)
            
        return helper(self.root, left ,right)
            

class Node:
    def __init__(self, start,end,total=0,left=None,right = None):
        self.start = start
        self.end = end
        self.total = total
        self.left = left
        self.right = right
```